//
//  CapabilitiesParser.swift
//  Swift-eSCL
//
//  Created by Leo Wehrfritz on 03.08.22.
//  Licensed under the MIT License
//

import Foundation

/**
 An object representing the ScannerCapabilities of a scanner.
 */
public struct Scanner {
    public var version: String = ""
    public var makeAndModel: String = ""
    // This contains the capabilities of each source.
    public var sourceCapabilities: [String: Capabilities] = [:]
    public var minWidth: Int = 0
    public var maxWidth: Int = 2550
    public var minHeight: Int = 0
    public var maxHeight: Int = 3510
    public var brightnessSupport: Support = Support()
    public var compressionFactorSupport: Support = Support()
    public var contrastSupport: Support = Support()
    public var sharpenSupport: Support = Support()
    public var thresholdSupport: Support = Support()
}

/**
 An object representing the capabilites of a single source on a scanner.
 */
public struct Capabilities {
    public var colorModes: [String] = []
    public var documentFormats: [String] = []
    public var supportedResolutions: [Int] = []
    public var supportedIntents: [String] = []
    public var colorSpaces: [String] = []
    public var ccdChannels: [String] = []
    public var contentTypes: [String] = []
}

public struct Support {
    public var min: Int = 0
    public var max: Int = 0
    public var normal: Int = 0
    public var step: Int = 0
}

/**
 A custom XMLParser with support for the structure generated by a scanner.
 */
class CapabilityParser: XMLParser {
    // Public property to hold the result
    var scanner: Scanner = Scanner()
    var capabilities = Capabilities()
    
    private var textBuffer: String = ""
    private var support: Support = Support()
    override init(data: Data) {
        super.init(data: data)
        self.delegate = self
    }
}

/**
 The actual parser
 */
extension CapabilityParser: XMLParserDelegate {
    // Called when opening tag (`<elementName>`) is found
    func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:]) {
        switch elementName {
        case "pwg:Version":
            textBuffer = ""
        case "pwg:MakeAndModel":
            textBuffer = ""
        case "scan:Platen":
            self.capabilities = Capabilities()
        case "scan:Adf":
            self.capabilities = Capabilities()
        case "scan:Camera":
            self.capabilities = Capabilities()
        case "scan:platen":
            self.capabilities = Capabilities()
        case "scan:adf":
            self.capabilities = Capabilities()
        case "scan:camera":
            self.capabilities = Capabilities()
        case "scan:MinWidth":
            textBuffer = ""
        case "scan:MaxWidth":
            textBuffer = ""
        case "scan:MinHeight":
            textBuffer = ""
        case "scan:MaxHeight":
            textBuffer = ""
        case "scan:ColorMode":
            textBuffer = ""
        case "pwg:DocumentFormat":
            textBuffer = ""
        case "scan:XResolution":
            textBuffer = ""
        case "scan:Intent":
            textBuffer = ""
        case "scan:ColorSpace":
            textBuffer = ""
        case "scan:CcdChannel":
            textBuffer = ""
        case "pwg:ContentType":
            textBuffer = ""
        case "scan:BrightnessSupport":
            support = Support()
        case "scan:CompressionFactorSupport":
            support = Support()
        case "scan:ContrastSupport":
            support = Support()
        case "scan:SharpenSupport":
            support = Support()
        case "scan:ThresholdSupport":
            support = Support()
        case "scan:Min":
            textBuffer = ""
        case "scan:Max":
            textBuffer = ""
        case "scan:Normal":
            textBuffer = ""
        case "scan:Step":
            textBuffer = ""
        default:
            //print("Ignoring \(elementName)")
            break
        }
    }
    
    // Called when closing tag (`</elementName>`) is found
    func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) {
        switch elementName {
        case "pwg:Version":
            self.scanner.version = textBuffer
        case "pwg:MakeAndModel":
            self.scanner.makeAndModel = textBuffer
        case "scan:Platen":
            self.scanner.sourceCapabilities["Platen"] = self.capabilities
        case "scan:platen":
            self.scanner.sourceCapabilities["Platen"] = self.capabilities
        case "scan:Adf":
            self.scanner.sourceCapabilities["Adf"] = self.capabilities
        case "scan:adf":
            self.scanner.sourceCapabilities["Adf"] = self.capabilities
        case "scan:Camera":
            self.scanner.sourceCapabilities["Camera"] = self.capabilities
        case "scan:camera":
            self.scanner.sourceCapabilities["Camera"] = self.capabilities
        case "scan:MinWidth":
            self.scanner.minWidth = Int(textBuffer) ?? 0
        case "scan:MaxWidth":
            self.scanner.maxWidth = Int(textBuffer) ?? 2550
        case "scan:MinHeight":
            self.scanner.minHeight = Int(textBuffer) ?? 0
        case "scan:MaxHeight":
            self.scanner.maxHeight = Int(textBuffer) ?? 3510
        case "scan:ColorMode":
            self.capabilities.colorModes.append(textBuffer)
        case "pwg:DocumentFormat":
            self.capabilities.documentFormats.append(textBuffer)
        case "scan:XResolution":
            self.capabilities.supportedResolutions.append(Int(textBuffer)!)
        case "scan:Intent":
            self.capabilities.supportedIntents.append(textBuffer)
        case "scan:ColorSpace":
            self.capabilities.colorSpaces.append(textBuffer)
        case "scan:CcdChannel":
            self.capabilities.ccdChannels.append(textBuffer)
        case "pwg:ContentType":
            self.capabilities.contentTypes.append(textBuffer)
        case "scan:BrightnessSupport":
            self.scanner.brightnessSupport = self.support
        case "scan:CompressionFactorSupport":
            self.scanner.compressionFactorSupport = self.support
        case "scan:ContrastSupport":
            self.scanner.contrastSupport = self.support
        case "scan:SharpenSupport":
            self.scanner.sharpenSupport = self.support
        case "scan:ThresholdSupport":
            self.scanner.thresholdSupport = self.support
        case "scan:Min":
            self.support.min = Int(textBuffer) ?? 0
        case "scan:Max":
            self.support.max = Int(textBuffer) ?? 0
        case "scan:Normal":
            self.support.normal = Int(textBuffer) ?? 0
        case "scan:Step":
            self.support.step = Int(textBuffer) ?? 0
        default:
            //print("Ignoring \(elementName)")
            break
        }
    }
    
    // Called when a character sequence is found
    // This may be called multiple times in a single element
    func parser(_ parser: XMLParser, foundCharacters string: String) {
        textBuffer += string
    }
    
    // Called when a CDATA block is found
    func parser(_ parser: XMLParser, foundCDATA CDATABlock: Data) {
        guard let string = String(data: CDATABlock, encoding: .utf8) else {
            print("CDATA contains non-textual data, ignored")
            return
        }
        textBuffer += string
    }
    
    // For debugging
    func parser(_ parser: XMLParser, parseErrorOccurred parseError: Error) {
        print(parseError)
        print("on:", parser.lineNumber, "at:", parser.columnNumber)
    }
}
